# 면접 준비 - 2주차 10/6 목

### SPA의 개념에 대해 설명해보세요

SPA는 Single Page Application의 줄인말입니다. 뜻 그대로 단일 페이지로 구성된 웹 어플리케이션입니다. 서버사이드 랜더링을 배제하고 필요한 데이터만 동적으로 랜더링합니다.

이전의 화면들은 매 요청마다 페이지 전체를 불러왔는데 SPA를 활용함으로서 페이지를 로딩하는 시간이 줄었습니다. 대신 처음 화면을 불러올 때 시간이 걸립니다.

HTML은 클라이언트 사이드에서 지니고 있고 컴포넌트별로 필요한 데이터만 요청하면 되기 때문에 속도가 향상됐습니다. 

### 웹 렌더링

1. HTML 파서에 HTML 코드가 들어옴
2. 파싱하여 DOM 트리 생성
3. 레이아웃을 잡고 화면에 그리는 작업을 수행

### DOM

기계나 SW가 웹 사이트의 구조를 어떻게 이해하는지에 대한 표준

DOM에 직접 접근하면 DOM Tree의 최상단에 있는 document DOM을 통해서 트리 밑으로 내려가면서 해당 DOM을 찾는 방식으로 접근

최상단 돔으로부터의 접근은 잦은 렌더링을 유발

작은 변경점조차 렌더링 과정을 반복하기 때문에 효율성이 떨어짐

### 가상 돔

별도 객체로 DOM 생성

별도의 공간(버퍼)에서 가상 DOM을 생성해 일정 동안 모은 뒤, 렌더링의 변경 시점이 생기면 그 때 가상 DOM으로부터 변경된 점을 일괄적으로 갱신

브라우저의 렌더링 횟수를 줄여 성능 개선을 도모

### SSR (Server Side Rendering)

서버에서 렌더링 작업

서버에서 html, view와 같은 리소스들을 어떻게 보여줄지 해석하고 렌더링해서 사용자에게 반환

### CSR (Client Side Rendering)

최초 1번 서버에서 전체 페이지를 로딩해서 보여주고 이후에는 요청때마다 리소스를 서버에서 제공한 후 클라이언트가 해석하고 레더링을 함

### SEO (Search Engine Optimization)

웹 크롤러들이 JS 파일을 실행시키지 못하고 HTML에서만 컨텐츠 수집

→ CSR 방식으로 개발 된 페이지들은 빈 페이지로 인식

### 보안

SSR에서는 사용자에 대한 정보를 서버 측에서 세션으로 관리

CRS에서는 클라이언트 측의 쿠키말고는 사용자에 대한 정보를 저장할 공간이 마땅치 않음

### ORM에 대해 설명해보세요

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결) 해주는 것

### 영속성

데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성

없으면 데이터는 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버림

### 영속성 레이어

Persistance Framework(Mybatis, Hibernate, JPA)을 이용한 개발이 이루어짐

![Untitled](https://user-images.githubusercontent.com/61227459/194760494-ab1c439c-e829-42fc-8112-9b0819f8a730.png)

### 장점

객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중 가능

재사용 및 유지보수 편리

DBMS에 대한 종속성이 줄어듬

### 단점

완변한 ORM은 없다

복잡

속도 저하 및 일관성이 무너짐

저장 프로시저를 쓰는 별도의 튜닝이 필요

자바에서는 Collection을 통해 Join 된 데이터를 가지고 있어야 하는 반면 테이블은 분리

→ JPA의 양방향 매핑이 안되는 이유

단방향 - 단방향 : 패러다임 불일치일때 객체지향적으로 RDB 사용 가능

SQL Injection 공격을 막아주는 기능이 있음

### java의 특징

1. 객체지향언어
    1. SOLID
    2. 추상화, 캡슐화, 상속, 다형성
2. 인터프리터 언어
    1. 컴파일 언어인 동시에 인터프리터 언어
    2. 텍스트 소스를 컴파일하여 클래스 파일로 만든 다음 자바 런타임이 클래스 파일을 인터프리트 하면서 실행
3. 독립적인 플랫폼
    1. 어떠한 운영체제라도 독립적으로 자바언어를 사용 - JVM
    2. JVM 구조

   ![Untitled 1](https://user-images.githubusercontent.com/61227459/194760495-b30c3ed9-6941-4cd2-9bee-7243d9d2dc2b.png)

   ![Untitled 2](https://user-images.githubusercontent.com/61227459/194760496-d295aafa-408b-49df-a9d3-53cf5f928160.png)
   
   ![Untitled 3](https://user-images.githubusercontent.com/61227459/194760499-24ad599a-eaa7-40bf-8d63-4e636df5ddf4.png)

4. 자동 메모리 관리
    1. 개발자가 메모리에 접근 불가 → 자바가 직접 관리
    2. 자동적으로 메모리 영역을 찾아서 할당 & 사용하지 않은 객체 제거
    3. GC 동작
5. 멀티 쓰레딩 지원
    1. 하나의 프로그램 단위가 동일한 쓰레드를 동시에 수행
    2. 자바 API를 사용하기 때문에 쉽게 구현 가능
    3. Thread 클래스 (화이트박스 방식)
        1. 스레드를 만들기 위해 Thread class 상속하여 스레드 생성
    4. Runnable 인터페이스 (블랙박스 방식)
        1. 다중상속이 지원되기 때문에 Thread class 보다 많이 쓰임
6. 동적
    1. 필요한 객체만 필요한 시점에 생성하여 사용
    2. 동적로딩은 클래스 일부 변경 시 다시 컴파일하지 않아도 됨
    3. 그때 그때 메모리에서 불러오기 때문에 프로그램 실행 속도가 정적로딩에 비해 느림
        1. 느린 속도 해결을 위해 static 키워드 사용
        2. 정적로딩 : 실행 시 모든 실행파일이 메모리에 적재되어 실행 (C언어) → 빠름
    4. 오류가 발생하면 발생한 오류의 클래스만 수정하면 되므로 전체를 수정할 필요 없음
7. 안전 + 강력
    1. 메모리를 자바가 관리하기 때문에 시스템 붕괴의 우려가 없음
    2. 포인터 개념이 없고 유형 정의가 강고하여 실행 전에 클래스 파일을 이용한 프로그램 검사 가능

### 1. mvc패턴 vs. mvvm 패턴
2. 다른 패턴들이 뭐가 있으며 그 특장점이 뭔지

### MVC 패턴

Model - View - Controller

데이터 처리 - 페이지 - 통제

효율적인 개발 및 유지보수

대규모의 프로젝트 같은 경우 Controller에 무리가 갈 수 있음

수정을 할 때 다른 부분에 영향을 끼칠 수 있음 (model - view 의존성)

![Untitled 4](https://user-images.githubusercontent.com/61227459/194760489-271ddac9-a00e-4fa3-be29-f63bfd332f9f.png)

### MVVM 패턴

Model - View - View Model

뷰와 뷰모델이 양방향 데이터 바인딩

테스트 용이성

확장성

로직과 프레젠테이션 계층은 느슨하게 결합

어설픈 UI 자동화 도구 없이 테스트가 가능

뷰를 추상화해서 비즈니스 로직 뒤에 있는 코드가 줄어듦

![Untitled 5](https://user-images.githubusercontent.com/61227459/194760492-f93df380-c8e5-4d18-8689-896f432dc143.png)

![Untitled 6](https://user-images.githubusercontent.com/61227459/194760493-a3e14361-1082-45b5-8b0b-2148540cc293.png)